<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="initial-scale=1.0, user-scalable=no, width=device-width"
    />
    <title>自定义三维图层</title>
    <link
      rel="stylesheet"
      href="https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css"
    />
    <style>
      html,
      body,
      #container {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script src="https://webapi.amap.com/maps?v=2.0&key=6ed38a1265faa551bd65434e43372c09"></script>
    <!-- 目前由于three 118 以上的版本对 GL 做了较大的改动，因此目前我们只支持到 117 版本 -->
    <script src="https://a.amap.com/jsapi_demos/static/demo-center-v2/three.js"></script>
    <script src="js/test_data.js"></script>

    <script type="text/javascript">
      var map = new AMap.Map("container", {
        center: [116.84655458822007, 38.34547386595896],
        zooms: [2, 20],
        zoom: 15,
        viewMode: "3D",
        pitch: 50,
      });

      var camera;
      var renderer;
      var scene;
      var meshes = [];
      // 数据转换工具
      var customCoords = map.customCoords;
      // 数据使用转换工具进行转换，这个操作必须要提前执行（在获取镜头参数 函数之前执行），否则将会获得一个错误信息。
      var data = customCoords.lngLatsToCoords([
        [116.52, 39.79],
        [116.54, 39.79],
        [116.56, 39.79],
      ]);

      // 创建 GL 图层
      var gllayer = new AMap.GLCustomLayer({
        // 图层的层级
        zIndex: 10,
        // 初始化的操作，创建图层过程中执行一次。
        init: (gl) => {
          // 这里我们的地图模式是 3D，所以创建一个透视相机，相机的参数初始化可以随意设置，因为在 render 函数中，每一帧都需要同步相机参数，因此这里变得不那么重要。
          // 如果你需要 2D 地图（viewMode: '2D'），那么你需要创建一个正交相机
          camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            100,
            1 << 30
          );

          renderer = new THREE.WebGLRenderer({
            context: gl, // 地图的 gl 上下文
            // alpha: true,
            // antialias: true,
            // canvas: gl.canvas,
          });

          // 自动清空画布这里必须设置为 false，否则地图底图将无法显示
          renderer.autoClear = false;
          scene = new THREE.Scene();

          // 环境光照和平行光
          var aLight = new THREE.AmbientLight(0xffffff, 0.3);
          var dLight = new THREE.DirectionalLight(0xffffff, 1);
          dLight.position.set(1000, -100, 900);
          scene.add(dLight);
          scene.add(aLight);

          // 圆柱体配置
          const RADIUS = 7;
          const SEGEMENT = 32;

          test_data.content.forEach((item) => {
            const node_list = JSON.parse(item.setNode);
            const deal_pos = customCoords.lngLatsToCoords(node_list);
            for (let i = 1; i < deal_pos.length; i++) {
              const a = deal_pos[i - 1];
              const b = deal_pos[i];
              const v = new THREE.Vector3(a[0] - b[0], a[1] - b[1], 0);
              const len = v.length();
              const theta =
                Math.atan((a[1] - b[1]) / (a[0] - b[0])) - Math.PI / 2;

              const c_geo = new THREE.CylinderGeometry(RADIUS, RADIUS, len, 32);
              const c_material = new THREE.MeshBasicMaterial({
                color: 0x66ccff,
              });
              const cylinder = new THREE.Mesh(c_geo, c_material);
              cylinder.position.set((a[0] + b[0]) / 2, (a[1] + b[1]) / 2, 0);
              cylinder.rotateZ(theta);

              scene.add(cylinder);
            }
          });

          const { content } = test_data;
          for (let i = 0; i < 0; i++) {
            // radiusTop, radiusBottom, height
            // radicalSegment, heightSegment
            // openEnded
            // thetaStart, thetalenght
            const geo = new THREE.CylinderGeometry(50, 50, 5000, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0x66ccff });
            let cylinder = new THREE.Mesh(geo, material);
            cylinder.position.set(deal_pos[0], deal_pos[1], 0);
            scene.add(cylinder);
          }
        },
        render: () => {
          // 这里必须执行！！重新设置 three 的 gl 上下文状态。
          renderer.state.reset();
          var {
            near,
            far,
            fov,
            up,
            lookAt,
            position,
          } = customCoords.getCameraParams();

          // 2D 地图下使用的正交相机
          // var { near, far, top, bottom, left, right, position, rotation } = customCoords.getCameraParams();

          // 这里的顺序不能颠倒，否则可能会出现绘制卡顿的效果。
          camera.near = near;
          camera.far = far;
          camera.fov = fov;
          camera.position.set(...position);
          camera.up.set(...up);
          camera.lookAt(...lookAt);
          camera.updateProjectionMatrix();

          renderer.render(scene, camera);
        },
      });
      map.add(gllayer);

      // 动画
      function animate() {
        for (let i = 0; i < meshes.length; i++) {
          let { mesh, count } = meshes[i];
          count += 1;
          mesh.rotateZ((count / 180) * Math.PI);
        }
        map.render();
        requestAnimationFrame(animate);
      }
      animate();
    </script>
  </body>
</html>
